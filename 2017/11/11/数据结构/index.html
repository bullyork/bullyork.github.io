<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="数据结构,">










<meta name="description" content="引子诚者自成也，而道自道也。 诚者，物之终始。不诚无物。是故君子诚之为贵。 诚者，非自成己而己也。所以成物也。成己仁也，成物知也。性之德也，合外内之道也。故时措之宜也。 –《中庸》 绪论数据结构  数据(data): 是对客观事物的符号表示。在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的      总称。 数据元素(data element)：是数据的基本单位，在计算机程序中通常">
<meta name="keywords" content="数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="http://bullyork.github.io/2017/11/11/数据结构/index.html">
<meta property="og:site_name" content="缘来我们在这里">
<meta property="og:description" content="引子诚者自成也，而道自道也。 诚者，物之终始。不诚无物。是故君子诚之为贵。 诚者，非自成己而己也。所以成物也。成己仁也，成物知也。性之德也，合外内之道也。故时措之宜也。 –《中庸》 绪论数据结构  数据(data): 是对客观事物的符号表示。在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的      总称。 数据元素(data element)：是数据的基本单位，在计算机程序中通常">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://imsproduction.oss-cn-shanghai.aliyuncs.com/5e10fb832932a2b66065fbd85c3e1c12.jpeg">
<meta property="og:image" content="http://imsproduction.oss-cn-shanghai.aliyuncs.com/5608d41af2541dff742f2ee55265ce3b.jpg">
<meta property="og:image" content="http://imsproduction.oss-cn-shanghai.aliyuncs.com/5a1954f7045046091af826e14a090c47.jpeg">
<meta property="og:updated_time" content="2019-02-13T03:12:35.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据结构">
<meta name="twitter:description" content="引子诚者自成也，而道自道也。 诚者，物之终始。不诚无物。是故君子诚之为贵。 诚者，非自成己而己也。所以成物也。成己仁也，成物知也。性之德也，合外内之道也。故时措之宜也。 –《中庸》 绪论数据结构  数据(data): 是对客观事物的符号表示。在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的      总称。 数据元素(data element)：是数据的基本单位，在计算机程序中通常">
<meta name="twitter:image" content="http://imsproduction.oss-cn-shanghai.aliyuncs.com/5e10fb832932a2b66065fbd85c3e1c12.jpeg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://bullyork.github.io/2017/11/11/数据结构/">





  <title>数据结构 | 缘来我们在这里</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">缘来我们在这里</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">乱世天狼的博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://bullyork.github.io/2017/11/11/数据结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="乱世天狼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="缘来我们在这里">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">数据结构</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-11T19:07:18+08:00">
                2017-11-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>诚者自成也，而道自道也。</p>
<p>诚者，物之终始。不诚无物。是故君子诚之为贵。</p>
<p>诚者，非自成己而己也。所以成物也。成己仁也，成物知也。性之德也，合外内之道也。故时措之宜也。</p>
<p>–《中庸》</p>
<h3 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h3><p><em>数据结构</em></p>
<ul>
<li>数据(data): 是对客观事物的符号表示。在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的      总称。</li>
<li>数据元素(data element)：是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理</li>
<li>数据对象(data object)：是性质相同的数据元素的集合，是数据的一个子集。</li>
<li>数据结构(data structure)：又称逻辑结构，是相互之间存在一种或多种特定关系的数据的集合，通常包括四种：集   合、线性结构、树形结构、网状结构。</li>
<li>存储结构：是数据结构在计算机中的表示。</li>
<li>数据类型(data type)：是一个值的集合和定义在这个值集上的一系列操作的总称。</li>
<li>抽象数据类型(AbstractData Type)：是指一个数据模型以及定义在该模型上的一组操作，可细分为：原子类型、固定聚合类型、可变聚合类型。</li>
</ul>
<p><em>算法</em></p>
<p>算法的5个重要特性：有穷性，确定性，可行性，输入，输出</p>
<p>衡量一个算法是否优秀，一般从以下几个点考虑：正确性，可读性，健壮性，时间复杂度，空间复杂度</p>
<p>一般情况下，算法中基本操作重复执行的次数时问题规模n的某个函数f(n)，算法的时间量度记作：T(n) = O(f(n))。他表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度。</p>
<p>类似时间复杂度，基本操作带来的空间消耗和问题规模n通常也有关系，这个关系叫空间复杂度：S(n) = O(f(n))。若输入数据所占空间只取决于问题本身，和算法无关，则只需要分析除输入和程序之外的额外空间，否则应该同时考虑输入本身所需空间。若额外空间相对于输入数据量来说是常数，则称此算法为原地工作。</p>
<p>算法书写规范</p>
<ul>
<li>算法说明：指明算法功能；参数表中各参量的含义和输入输出属性；算法中引入了哪些全局变量或外部定义的变量，作用入口初值以及应满足哪些限制条件</li>
<li>注释和断言：注释抽象度应高于语句，断言用来陈述算法执行到此处应该满足的条件</li>
<li>输入和输出：scanf和printf语句；参数显示；全局变量或外部变量隐式的传递信息</li>
<li>错误处理：尽可能使用函数返回算法的执行状态，便于调用者处理异常情况，有益于培养良好的程序设计习惯</li>
<li>语句选用和算法结构：尽量不使用goto</li>
<li>基本运算：自己实现</li>
<li>建议：使用图说明算法；用边界条件检测算法</li>
</ul>
<h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><p>线性表和单链表</p>
<h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><p><em>栈和队列</em></p>
<p>表达式求值：算符优先法</p>
<p>为了实现算符优先法，可以使用两个工作栈，一个称作OPTR，用来寄存运算符，另一个称为OPND用来寄存操作数或运算结果。</p>
<ol>
<li>首先置操作数栈为空栈，表达式起止符‘#’为栈底元素</li>
<li>依次读入表达式中的每个字符，若是操作数则进OPND栈，若是运算符则和OPTR栈的栈顶运算符比较优先权后作相应操作，直至整个表达式求值完毕（即OPTR的栈顶元素和当前读入字符均为‘#’）</li>
</ol>
<p><em>栈与递归的实现</em></p>
<p>递归：一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称作递归函数。</p>
<p><a href="https://baike.baidu.com/item/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/1945186?fr=aladdin" target="_blank" rel="noopener">hanoi问题</a>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveH</span><span class="params">(<span class="keyword">char</span> *x, <span class="keyword">int</span> n, <span class="keyword">char</span> *z)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%i. Move disk %i from %s to %s\n"</span>, ++c, n, x, z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> *x, <span class="keyword">char</span> *y, <span class="keyword">char</span> *z)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 将塔座x上按直径由小到大且自上而下编号为1到n的n个圆盘按规则搬到塔座z上，y可以作为辅助塔座。(c是初值为0的全局变量，对搬动记数)</span></span><br><span class="line">    <span class="comment">// 搬动操作move(x,n,z)可定义为: printf("%i. Move disk %i from %c to %c\n", ++c, n, x, z);</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        moveH(x, <span class="number">1</span>, z);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hanoi(n<span class="number">-1</span>, x, z, y);</span><br><span class="line">        moveH(x, n, z);</span><br><span class="line">        hanoi(n<span class="number">-1</span>, y, x, z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> first[<span class="number">20</span>] = <span class="string">"第一个柱子"</span>;</span><br><span class="line">    <span class="keyword">char</span> second[<span class="number">20</span>] = <span class="string">"第二个柱子"</span>;</span><br><span class="line">    <span class="keyword">char</span> third[<span class="number">20</span>] = <span class="string">"第三个柱子"</span>;</span><br><span class="line">    </span><br><span class="line">    hanoi(<span class="number">10</span>, first, second, third);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>递归的实现：调用函数和被调用函之间的链接及信息交换需要通过栈来执行</p>
<p>在运行被调用函数之前，系统需要先完成3件事</p>
<ol>
<li>将所有的实参、返回地址等信息传递给被调用函数保存</li>
<li>为被调用函数的局部变量分配存储区</li>
<li>将控制转移到被调用函数的入口</li>
</ol>
<p>从被调用函数返回调用函数之前，系统也要完成三件工作</p>
<ol>
<li>保存被调用函数的计算结果</li>
<li>释放被调用函数的数据区</li>
<li>依照被调用函数保存的返回地址将控制转移到调用函数</li>
</ol>
<p><em>队列</em></p>
<p>循环队列</p>
<p><em>离散事件模拟</em></p>
<p>略</p>
<h3 id="第四章-串"><a href="#第四章-串" class="headerlink" title="第四章 串"></a>第四章 串</h3><p><em>kmp算法（克努特-莫里斯-普拉特算法）</em></p>
<p>思路：模式串本身是已知量，已知量，若和待匹配字符串已经出现部分匹配，则根据这部分匹配我们可以得知，再进行匹配需要滑动的距离。根本目的在于减少重复计算量</p>
<p>关键：next函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// j是模式串的下标，k是滑动距离</span><br><span class="line">next[j] = k</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>tips: 求next函数的过程其实也是一个递归的过程，哈哈哈哈，考虑相同字符问题可以对算法进行修正，得到更好的答案。此算法启示为对细节孜孜不倦的苛求，可以有颠覆的结论。</p>
</blockquote>
<h3 id="第五章-数组和广义表"><a href="#第五章-数组和广义表" class="headerlink" title="第五章 数组和广义表"></a>第五章 数组和广义表</h3><p><em>矩阵的压缩存储</em></p>
<p>压缩存储是指：为多个值相同的元只分配一个存储空间，对零元不分配空间</p>
<p><a href="https://baike.baidu.com/item/%E7%9F%A9%E9%98%B5/18069?fr=aladdin" target="_blank" rel="noopener">矩阵</a>运算: 加法，减法，数乘，转置，共轭，共轭转置，乘法，行列式</p>
<p>对称矩阵，三角矩阵，对角矩阵</p>
<p>稀疏矩阵：三元组存储法(位置，值)</p>
<p><em>广义表</em></p>
<p>广义表一般记作：LS = $(a_1,a_2,…,a_n)$</p>
<p>$a_i$可以是单个元素，也可以是子表，分别称为<code>原子</code>和<code>子表</code>。习惯上用大写字母表示广义表的名称，用小写字母表示广义表的原子，表非空时，习惯称第一个元素为<code>表头</code>，其余元素组成的表为<code>表尾</code></p>
<p><em>广义表的存储结构</em></p>
<p>通常采用链式存储。</p>
<p><em>m元多项式的表示</em></p>
<ol>
<li>$P(x,y,x) = x^{10}y^3z^2 + 2x^6y^3z^2 + 3x^5y^2z^2 + x^4y^4z + 6x^3y^4z + 2yz + 15$</li>
<li>$P(x,y,x) = ((x^10+2x^6)y^3 + 3x^5y^2)z^2 + ((x^4+6x^3)y^4 + 2y)z + 15$</li>
<li>广义表表示：$P = z((A,2),(B,1),(15,0))$ (数字代表变元的幂次)</li>
<li>其中$A = y((C, 3), (D, 2)) C = x((1, 10), (2, 6)) D = x((3, 5)) B = y((E, 4), (F, 1)) E = x((1, 4), (6, 3)) F = x(2, 0)$</li>
</ol>
<p><em>广义表的递归算法</em></p>
<p>分治法设计递归算法</p>
<ol>
<li>首先应书写函数的首部和规格说明，严格定义函数的功能和接口（递归调用的界面），对求精函数中所得的和原问题性质相同的子问题，只要接口一致，便可进行递归调用</li>
<li>对函数中的每一个递归调用都看成只是一个简单的操作，只要接口一致，必能实现规格说明中定义的功能，切忌想的太深太远。</li>
</ol>
<blockquote>
<p>重要的是递归思想的理解和运用</p>
</blockquote>
<h3 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h3><p>树的定义：树(Tree)是n(n&gt;=0)个结点的有限集，在任何一个非空树中，树特征：</p>
<ul>
<li>有且只有一个特定的称为根(Root)的结点</li>
<li>当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集$T_1,T_2…,T_m$，其中每一个集合本身又是一棵树，并且称为根的<code>子树(subtree)</code></li>
</ul>
<p>树的<code>结点</code>包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为<code>结点的度</code>(Degree)。度为0的结点称为<code>非终端结点</code>或<code>分支结点</code>。除根节点之外，分支结点也称为内部结点。<code>树的度</code>是树内各结点的度的最大值。结点的子树的根的根称为该结点的孩子(Child)，相应地，该结点称为孩子的双亲(Parent)。同一个双亲的孩子之间互称为<code>兄弟</code>。结点的<code>祖先</code>是从根到该节点所经分支上的所有结点。以某结点为根的子树中的任一节点都称为该节点的<code>子孙</code>。</p>
<p>结点的<code>层次</code>从根开始定义，根为第一层，根的孩子为第二层。其双亲在同一层的结点互为<code>堂兄弟</code>。树中结点的最大层次称为树的<code>深度</code>(Depth)或高度。</p>
<p>如果树的结点的各子树看成从左至右是有次序的（即不能互换），则称该树为<code>有序树</code>，否则称为<code>无序树</code>。在有序树中，最左边子树的根称为第一个孩子，最右边的称为最后一个孩子。</p>
<p><code>森林(Forest)</code>是m(m&gt;0)棵互不相交的树的集合。对树中的每个结点而言，其子树的集合即为森林。由此，也可以森林和树相互递归的定义来描述树。</p>
<p>Tree = (root, F);$F=(T_1,T_2,…,T_m);T_i=(r_i, F_i)$</p>
<p><em>二叉树</em></p>
<p>二叉树是另一种树形结构，它的特点是每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点），并且，二叉树的子树有左右之分，其次序不能任意颠倒。</p>
<p>二叉树有五种形态：空二叉树，仅有根节点的二叉树，右子树为空的二叉树，左右子树均非空的二叉树，左子树为空的二叉树</p>
<p>二叉树的性质：</p>
<ol>
<li>在二叉树第i层上至多有$2^{i-1}$个结点</li>
<li>深度为k的二叉树至多有$2^k-1$个结点</li>
<li>对任何一个二叉树，如果其终端结点数为$n_0$，度为2的结点数为$n_2$。则$n_0 = n_2+1$。思路：节点总数为$n = n_0 + n_1 + n_2$；根据分支推出等式：$ n - 1 = B = n_1 + 2n_2$；结合两个等式即可推出。一颗深度为k且有$2^k-1$个结点得二叉树称为<code>满二叉树</code>。深度为k的，有n个结点的二叉树，当且仅当其每一点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称之为<code>完全二叉树</code>。</li>
<li>具有n个结点的完全二叉树的深度为$\lfloor log_2n\rfloor + 1$</li>
<li>对于一颗有n个结点的完全二叉树的结点按层序编号，则对任一结点i，有：<ul>
<li>i=1，此结点为根节点；i&gt;1，则其双亲PARENT(i)是结点$\lfloor i/2 \rfloor$</li>
<li>如果2i&gt;n,则结点i无左孩子；否则其左孩子LCHIL(i)是结点2i</li>
<li>如果2i+1&gt;n，则结点i无右孩子；否则其右孩子RCHILD(i)是结点2i+1<br>二叉树的存储结构</li>
</ul>
</li>
</ol>
<p>顺序存储：最坏的情况，一个深度为k且有k个结点的二叉树却需要长度为$2^k-1$的一维数组</p>
<p>链式存储：二叉链表和三叉链表</p>
<p>遍历二叉树和线索二叉树</p>
<p>特点：先序中序后序是根据根结点的位置定的，顺序是先左后右</p>
<ol>
<li>先序遍历二叉树操作定义(DLR):<ol>
<li>访问根结点</li>
<li>先序遍历左子树</li>
<li>先序遍历右子树</li>
</ol>
</li>
<li>中序遍历二叉树的操作定义(LDR):<ol>
<li>中序遍历左子树</li>
<li>访问根结点</li>
<li>中序遍历右子树</li>
</ol>
</li>
<li>后序遍历二叉树的操作定义(LRD):<ol>
<li>后序遍历左子树</li>
<li>后序遍历右子树</li>
<li>访问根结点</li>
</ol>
</li>
</ol>
<p>从中序遍历递归算法执行过程中递归工作栈的状态可见：</p>
<ol>
<li>工作记录中包含两项，其一是递归调用的语句编号，其二是指向根结点的指针，则当栈顶记录中的指针非空时，应遍历左子树，即指向左子树根的结点入栈。</li>
<li>若栈顶记录种的指针值为空，则应退至上一层，若是从左子树返回，则应访问当前层即栈顶记录中指针所指的根结点。</li>
<li>若是从右子树返回则表明当前层的遍历技术，应继续退栈。从另一角度看，这意味着，遍历右子树时不再需要保存当前层的根指针，可直接修改栈顶记录中的指针即可。</li>
</ol>
<p>“遍历”是二叉树各种操作的基础，可以在遍历过程中对结点进行各种操作，如：对于一棵已知树可求结点的双亲，求结点的孩子结点，判定结点所在层次，反之，也可在遍历的过程中生成结点，建立二叉树的存储结构。</p>
<p>对二叉树进行遍历的搜索路径除了上述先序、中序、后序外，还可以从上到下、从左到右按层次进行。</p>
<p>显然，遍历二叉树的算法中的基本操作是访问结点，则不论按哪一种次序进行遍历，对含n个结点的二叉树，其时间复杂度均为O(n)。所需辅助空间为遍历过程中栈的最大容量，即树的深度，最坏情况下为n，则空间复杂度也为O(n)。遍历的时候也可以采用二叉树的其他存储结构，如带标志域的三叉链表，此时因存储结构中已存有遍历所需足够信息，则遍历过程中不需另设栈。</p>
<p><em>线索二叉树</em></p>
<p>如下规定：若结点有左子树，则其lchild域指示其左孩子，否则令lchild域指示其前驱；若结点有右子树，则其rchild域指示其右孩子，否则令rchild域指示其后继。为了避免混淆，还需要改变结点结构，增加两个标志域：lchild,LTag,data,RTag,rchild。其中LTag取值0，1，分别代表lchild域指示左孩子，前驱。RTag同理。</p>
<p>以这种节点结构构成的二叉链表作为二叉树的存储结构，叫做<code>线索链表</code>，其中指向结点前驱和后继的指针，叫做<code>线索</code>。加上线索的二叉树称之为<code>线索二叉树</code>。对二叉树以某种次序遍历使其变为线索二叉树的过程叫做<code>线索化</code>。</p>
<p><em>树和森林</em></p>
<p>树得存储结构</p>
<p>双亲表示法：一组连续空间存储树的结点，同时在每个结点中附设一个指示器指示其双亲结点在链表中的位置。</p>
<p>孩子表示法：把每个结点的孩子结点排列起来，看成一个线性表，且以单链表作为存储结构，则n个结点有n个孩子链表。而n个头指针又组成一个线性表</p>
<p>孩子兄弟表示法：又称二叉树表示法，或二叉链表示法。即以二叉链表作树的存储结构。链表中结点的两个链域分别指向该节点的第一个孩子结点和下一个兄弟结点。（按照这个思想，所有的树都可以转换为二叉树！！）</p>
<p><em>森林与二叉树的转换</em></p>
<p>从树的二叉链表示法可知，任何一课和树对应的二叉树，其右子树必然为空，若把森林中下一棵树看成前一棵树的根结点二叉树表示的右儿子，则同样可以导出二叉树和森林的对应关系</p>
<p><em>树和森林的遍历</em></p>
<p>同样分为：先序遍历，中序遍历，后序遍历</p>
<p><em>树与等价关系</em></p>
<p>概念：等价关系，等价类，利用树可以划分等价类</p>
<h4 id="赫夫曼树及其应用"><a href="#赫夫曼树及其应用" class="headerlink" title="赫夫曼树及其应用"></a>赫夫曼树及其应用</h4><p>从树中一个结点到另一个结点的分支构成这两者之间的路径，路径上的分支数目称为<code>路径长度</code>。<code>树的路径长度</code>是从树根到每一个结点的路径长度之和。<code>树的带权路径长度</code>为树中所有叶子结点的带权路径长度之和，通常记作: $WPL = \sum_{k=1}^{n}w_kl_k$</p>
<p>假设有n个权值${w_1,w_2,…,w_n}$，试构造有n个叶子结点的二叉树，每个叶子结点带权值为$w_i$，其中带权路径长度WPL最小的二叉树称作<code>最优二叉树</code>或<code>赫夫曼树</code></p>
<p><em>赫夫曼算法</em></p>
<ol>
<li>根据给定的n个权值${w_1,w_2,…,w_n}$构成n棵二叉树的集合$F={T_1,T_2,…,T_n}$，其中每一棵二叉树$T_i$中只有一个带权为$W_i$的根结点，其左右子树均空</li>
<li>在F中选取两棵根结点的权值最小的树作为左右子树构造一颗新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。</li>
<li>在F中删除这两棵树，同时将新得到的二叉树加入到F中</li>
<li>重复2，3步骤，直到F中只含有一颗树为止。这棵树便是赫夫曼树</li>
</ol>
<p><em>赫夫曼编码</em></p>
<p>若要设计长短不等的编码，则必须是任一个字符的编码都不是另一个字符的编码的前缀，这种编码称做<code>前缀编码</code></p>
<p><img src="http://imsproduction.oss-cn-shanghai.aliyuncs.com/5e10fb832932a2b66065fbd85c3e1c12.jpeg" alt="赫夫曼编码" title="这是赫夫曼编码的图示"></p>
<p>假设每种字符在电文中出现的次数为$w_i$，其编码长度为$l_i$，电文中只有n种字符，则电文总长为$\sum_{i=1}^{n}w_il_i$。对应到二叉树上，若置$w_i$为叶子结点的权，$l_i$恰为从根到叶子的路径长度。则$\sum_{i=1}^{n}w_il_i$恰为二叉树上的带全路径长度。由此可见，设计电文最短的二进制前缀编码即以n种字符出现的频率作权，设计一棵赫夫曼树的问题，由此得到的二进制前缀编码称为赫夫曼编码。</p>
<p><em>回溯法与树的遍历</em></p>
<p>在程序设计中，有相当一类求一组解、或求全部解或求最优解的问题，例如：<a href="https://baike.baidu.com/item/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/11053477?fr=aladdin" target="_blank" rel="noopener">八皇后问题</a>。不是根据某种确定的计算法则，而是利用试探和<code>回溯</code>得搜索技术求解。回溯法也是递归设计的一种重要的方法，它的求解实质上是一个先序遍历一棵‘状态树’的过程，只是这棵树不是遍历前预先建立的，而是隐含在遍历过程中，但如果认识到这点，很多问题的递归过程也就迎刃而解了。</p>
<p>题目：求含n个元素的集合的幂集。<br>集合A的幂集是由集合A的所有的子集所组成的集合。则A得幂集为$\rho(A)$。</p>
<p>可以利用分治法来设计解法，在此，从另一角度分析问题。幂集的每个元素是一个集合，它或是空集，或含集合A中的一个元素，或集合A中的两个元素，或等于集合A。反之，从集合A的每个元素看，它只有两种状态：它或属于幂集的元素集，或不属于A的幂集元素集。则求$\rho(A)$的元素的过程可看成是依次对集合A中元素进行取或舍的过程，并且可以用一棵树来表示。</p>
<p><img src="http://imsproduction.oss-cn-shanghai.aliyuncs.com/5608d41af2541dff742f2ee55265ce3b.jpg" alt="回溯法" title="这是回溯法解集合幂集的图示"></p>
<p>算法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PowerSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//求含n个元素的集合A的幂集$\rho(A)$。进入函数时已对A中前i-1个元素做了取舍处理，现从第i个元素起进行取舍处理。若i&gt;n则求得幂集的一个元素并输出之，初始调用：PowerSet(1, n)</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt; n) 输出幂集的一个元素；</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        取第i个元素: PowerSet(i+<span class="number">1</span>, n);</span><br><span class="line">        舍第i个元素: PowerSet(i+<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// PowerSet</span></span><br></pre></td></tr></table></figure></p>
<p>上述问题的解决是一个满二叉树，树中每个叶子结点的状态都是求解过程中可能出现的状态(即问题的解)。然而很多问题用回溯法和试探求解的时候，描述求解过程的状态树不是一棵满的多叉树。当时谈过程中出现的状态和问题求解产生矛盾时，不再继续试探下去。这时出现得叶子结点不是问题的解的终结状态。这类问题的求解过程可看成是在约束条件下进行先序遍历，并在遍历过程中剪去那些不满足条件的分支。</p>
<p><em>树的技术</em></p>
<p>推导过程较麻烦，略，有用到再说</p>
<p>揭露：n个结点的不想似的二叉树有$\frac{1}{n+1}C^n_{2n}$</p>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>图是一种数据结构，加上一组基本操作，就构成了抽象数据类型。在图形结构中，结点之间的关系可以是任意的，图中任意两个元素之间都有可能相关。</p>
<p>在图中的数据元素通常称为<code>顶点</code>(Vertex)，V是顶点的有穷非空集合；VR是两个顶点之间的关系的集合。若$&lt;\nu,\omega&gt;\in VR$，则$&lt;\nu,\omega&gt;$表示从$\nu$到$\omega$的一条<code>弧</code>(Arc)。且称$\nu$为<code>弧尾</code>或初始点(Initial node)，称$\omega$为弧头(HEAD)或终端点(Terminal node)，此时的图称为<code>有向图</code>(Digraph)。若$&lt;\nu,\omega&gt;\in VR$，则必有$&lt;\omega,\nu&gt;\in VR$。即VR是对称的，则以无序对$(\nu,\omega)$代替这两个有序对，表示$\nu$和$\omega$的一条<code>边</code>(Edge)，此时的图称为<code>无向图</code>(Undigraph)。</p>
<p>我们用n表示图中顶点的数目，用e表示边或弧的数目。在下面的讨论中，我们不考虑顶点到其自身的弧或边，即若$&lt;\nu_i, \nu_j&gt; \in VR$则$i \not= j$，那么，对于无向图，e的取值范围是0到$\frac{1}{2}n(n-1)$。有$\frac{1}{2}n(n-1)$条边的无向图称为<code>完全图</code>(Completed graph)。对于有向图e的取值范围是0到$n(n-1)$。具有$n(n-1)$条弧的有向图称为有向完全图。又很少条边或弧(如$e &lt; nlogn$)的图称为<code>稀疏图</code>(Sparse grapth)。反之称为<code>稠密图</code>(Dense grapth)。</p>
<p>有时图的边或弧具有与它相关的数，这种与图的边或弧相关的数叫做<code>权</code>(Weight)。这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为<code>网</code>(Network)。</p>
<p>假设有两个图G = (V, {E})和G’ = (V’, {E’})，如果$V’\subseteq V$且$E’\subseteq E$，则称G’为G的子图(Subgraph)。</p>
<p>对于无向图G = (V, {E})，如果边$(v, v’) \in E$，则称v,v’互为邻接点(Ajacent)。即v和v’相邻接。边(v,v’)<code>依附</code>(Incident)于定点v和v’，或者说(v,v’)和定点v和v’<code>相关联</code>。顶点v的<code>度</code>(Degree)是和v相关联的边的数目。记为TD(V)。以顶点v为头的弧的数目称为<code>入度</code>(InDegree)，记为ID(V)。以v为尾的弧的数目称为v的<code>出度</code>(Outdegree)，记为OD(v);顶点v的度为TD(v) = ID(v) + OD(v);</p>
<p>无向图G = (V, {E})中从顶点$\nu$到$\nu’$的<code>路径</code>(Path)。如果G是有向图，则路径也是有向的，顶点序列应该满足$&lt; \nu_{i-1}, \nu_i &gt; \in E$。路径的长度是路径上的边或弧的数目。第一个顶点和最后一个顶点相同的路径称为<code>回路</code>或<code>环</code>。序列中顶点不重复出现的路径称为<code>简单路径</code>。除了第一个顶点和最后一个顶点，其余顶点不重复出现的回路，称为简单回路或简单环。</p>
<p>在无向图G中，如果从定点v到v’有路径，则称v和v’是<code>连通</code>的。如果对于图中任意两个顶点都是连通的，则称G为<code>连通图</code>(Connected Graph)。<code>连通分量</code>(Connected component)，指的是无向图中的极大连通子图。</p>
<p>在有向图中，如果对于每一对顶点，相互之间都存在路径，则称G是<code>强连通图</code>。有向图的极大连通子图称为有向图的<code>强连通分量</code>。</p>
<p>一个连通图的<code>生成树</code>是一个极小连通子图。</p>
<p>如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一棵有向树。一个有向图的<code>生成森林</code>由若干棵有向树组成，含有图中全部定点，但只有足以构成若干棵不相交的有向树的弧。</p>
<p>可对某个顶点的所有邻接点进行排队，在这个排队中自然形成了第一个或第k哥邻接点。若某个顶点的邻接点的排序大于k，则称第k+1个邻接点为第k个邻接点的下一个邻接点，而最后一个邻接点的下一个邻接点为’空’。</p>
<p><em>图的存储结构</em></p>
<p>自然采取多重链表的存储结构。由于途中各顶点度不同，最大度数和最小度数可能相差很多，因此，若按度数最大的定点设计结点结构，则会浪费很多单元；反之，按每个顶点自己的度数设计不通的结点结构，又会给操作带来不便。因此，和树类似，在实际应用中不宜采用这种结构，而应根据具体的图和需要进行的操作，设计恰当的结点结构和表结构。常用的有邻接表，邻接多重表和十字链表。</p>
<p>邻接矩阵表示法：使用矩阵存储顶点间相互关系，n个结点构成n*n矩阵。优点：直观，清晰。缺点：占用存储空间大</p>
<p><code>邻接表</code>: 思路是每个顶点建立一个单链表，存储其邻接边信息。这样若无向图中有n个结点、e条边，则它的邻接表需n个头结点和2e个表结点。显然在边稀疏的情况下，用邻接表表示图比邻接矩阵节省存储空间。当和边相关的信息多时更是如此。邻接表判定两个顶点是否有边或弧链接，没有邻接矩阵方便</p>
<p><code>十字链表</code>: 弧结点：tailvex | headvex | hlink | tlink | info 顶点结点：data | firstin | firstout。类似邻接表，但更容易找到以顶点为头或尾的弧。在某些有向图中很有用。</p>
<p><code>邻接多重表</code>：和十字链表类似。无向图的另一种链式存储结构。边结点：mark | ivex | ilink | jvex | jlink | info 。顶点结点：data | firstedge</p>
<p><em>图的遍历</em></p>
<p>和树的遍历类似，在此，我们希望从图中的某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次。这一过程叫做<strong>图的遍历</strong>。图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础。</p>
<p>通常有两种遍历图的路径：深度优先搜索和广度优先搜索。</p>
<p><code>深度优先搜索</code>: 此遍历类似于树的先根遍历，是树的先根遍历的推广。深度优先搜索可从图中某个顶点v出发，访问此顶点，然后依次从v的未被访问的邻接点出发深度优先遍历图。</p>
<p>深度优先搜索，邻接矩阵的时间复杂度为$O(n^2)$，邻接表的时间复杂度为O(n+e)。</p>
<p><code>广度优先搜索</code>: 类似于树的按层遍历的过程。假设从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”被访问，直至图中所有已被访问的顶点的邻接点都被访问到。若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直到所有顶点被访问到为止。</p>
<p><em>图的连通性</em></p>
<p>连通图：从图中任意顶点进行深度优先或广度有限访问，都能访问到所有的顶点</p>
<p>深度优先搜索过程生成的树为深度优先生成树；广度优先搜索过程生成的数为广度优先生成树</p>
<p>非连通图，对应深度优先生成森林，广度优先生成森林</p>
<p><code>强连通分量</code>: 有向图强连通分量：在有向图G中，如果两个顶点vi,vj间（vi&gt;vj）有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。</p>
<p><code>最小生成树</code>: 假设要在n个城市之间建立通信联络网，则n个城市只需要n-1条线路。如何在最节省经费的前提下建立这个通信网。可以用连通网来表示这个问题，我们需要寻找到一棵耗费最小的生成树，这个问题就是<code>最小生成树</code>问题</p>
<p><code>MST</code>性质：假设 N = (V, {E})是一个连通网，U是顶点集V的一个非空子集。若(u,v)是一条具有最小权值（代价）的边，其中$u \in U,v \in V - U$则必存在一棵包含边$(u, v)$的最小生成树</p>
<p><code>普里姆算法</code>：假设 N = (V, {E})是一个连通网，TE是N上最小生成树中边的集合。算法从U = { $\mu_0$ }$(\mu_0 \in V)$，TE = {} 开始，重复执行下述操作：在所有$u \in U, v \in V - U$的边$(u,v) \in E$中找一条代价最小的边$(u_0, v_0)$并入集合TE，同时$v_0$并入U，直至U = V为止。此时TE中必有n-1条边，则T = (V, {TE})为N的最小生成树。</p>
<p>普里姆算法时间复杂度为$O(n^2)$(其中n为顶点数)。所以普里姆算法适合求边稠密的网的最小生成树</p>
<p><code>克鲁斯卡尔算法</code>：假设连通网N = (V, {E})，则令最小生成树的初始状态为只有n个顶点而无边的非联通图T = (V, {})，图中每个顶点自成一个连通分量。在E中选择代价最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加入到T当中，否则舍去此边而选择下一条代价最小的边。依次类推，直至T中所有顶点都在同一连通分量上为止。时间复杂度为$O(eloge)$(e为边数)，因此适合求边稀疏的网的最小生成树</p>
<p><code>关节点</code>：假若在删去顶点v以及和v相关联的各边之后，将图的一个连通分量分割成两个或两个以上的连通分量，则称顶点v为该图的一个<code>关节点</code>(articulation point)。</p>
<p>一个没有<code>关节点</code>的连通图称为<code>重连通图</code>(biconnected graph)。若连通图中至少删去k个顶点才能破坏图的连通性，则称此图的连通度为k。</p>
<p>一个无环的有向图称为<code>有向无环图</code>(directed acycline graph)，简称DAG图。</p>
<p>有向无环图是描述含有公共子式的表达式的有效工具。例如下述表达式：((a+b)*(b*(c+d))+(c+d)*e)*((c+d)*e)</p>
<p><img src="http://imsproduction.oss-cn-shanghai.aliyuncs.com/5a1954f7045046091af826e14a090c47.jpeg" alt="有向无环图应用示例" title="这是有向无环图应用示例"></p>
<p>有向无环图也是描述一项工程或系统的进行过程的有效工具。除最简单的情况之外，几乎所有的工程都可分为若干个称作<code>活动</code>的子工程，而这些子工程之间，通常受着一定条件的约束，如其中某些子工程的开始必须在另一些子工程完成之后。对于整个工程和系统，人们关心的是两个方面的问题：一是工程能否顺利进行；二是估算整个工程完成所必需的最短时间。</p>
<p><code>自反关系</code>：设 R是 A上的一个二元关系，若对于 A中的每一个元素 a， (a,a)都属于 R，则称 R为自反关系。换言之，在自反关系中， A中每一个元素与其自身相关</p>
<p><code>反对称关系</code>：反对称性是一个关于数学上二元关系的性质。大概地说，集合 X 上的二元关系 R 是反对称的，当且仅当不存在X里的一对相异元素a, b，它们 R-关系于彼此。</p>
<p><code>传递关系</code>：在逻辑学和数学中，若对所有的 a，b，c 属于 X，下述语句保持有效，则集合 X 上的二元关系 R 是传递的：「若a 关系到 b 且 b 关系到 c， 则 a 关系到 c。」</p>
<p><code>偏序</code>和<code>全序</code></p>
<p>偏序和全序是公里集合论中的概念。</p>
<p>首先你要知道什么是二元关系。<br>比如实数中的“大小”关系，集合的集合中的“包含”关系就是两种二元关系。</p>
<p>所谓偏序，即偏序关系，是一种二元关系。<br>所谓全序，即全序关系，自然也是一种二元关系。</p>
<p>全序是指，集合中的任两个元素之间都可以比较的关系。比如实数中的任两个数都可以比较大小，那么“大小”就是实数集的一个全序关系。</p>
<p>偏序是指，集合中只有部分元素之间可以比较的关系。比如复数集中并不是所有的数都可以比较大小，那么“大小”就是复数集的一个偏序关系。</p>
<p>显然，全序关系必是偏序关系。反之不成立。</p>
<p>拓扑排序：由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。</p>
<p>这种用顶点表示活动，用弧表示活动间的优先关系的有向图称为顶点表示活动的网(Activity On Vertex Network)。简称AOV-网</p>
<p><em>拓扑排序</em></p>
<ol>
<li>在有向图中选一个没有前驱的顶点且输出之</li>
<li>从图中删除该顶点和所有以它为尾的弧</li>
</ol>
<p>重复上述两步，直至全部顶点均已输出，或者当前图中不存在无前驱的顶点为止，后一种情况说明有向图中存在环</p>
<p><em>关键路径</em></p>
<p>与AOV-网相对应的是AOE-网(Activity On Edge)即表示活动的网。AOE-网是一个带权的有向无环图，其中顶点表示事件(Event)，弧表示活动，权表示活动持续时间。</p>
<p>AOE-网有待研究的问题是：1，完成整项工程至少需要多少时间。2，哪些活动是影响工程进度的关键</p>
<p>由于在AOE-网中有些活动可以并行的进行，所以完成工程的最短时间是从开始点到完成点的最长路径的长度。路径长度最长的路径叫做<code>关键路径</code>(Critical Path)。</p>
<p>关键路径的算法：</p>
<ol>
<li>输入e条弧&lt;j,k&gt;。建立AOE-网的存储结构</li>
<li>从源点$v_0$出发，令ve[0] = 0，按拓扑有序求其余各顶点的最早发生时间$ ve[i] (1 \le i \le (n-1)) $。如果得到的拓扑有序中顶点个数小于网中顶点数n，则说明网中存在环，不能求关键路径，算法终止；否则执行步骤3</li>
<li>从汇点$v_n$出发，令vl[n-1] = ve[n-1]，按逆拓扑有序求其余各顶点的最迟发生时间$vl<a href="n-2 \ge i \ge 2">i</a>$。</li>
<li>根据各点的ve和vl值，求每条弧s的最早开始时间e(s)和最迟开始时间ls(s)。若某条弧满足条件e(s)=l(s)，则为关键活动。</li>
</ol>
<blockquote>
<p>理解要点，求关键活动 –&gt; 各事件最早发生时间和最迟发生时间 –&gt; 求弧的最早发生时间和最迟发生时间 –&gt; 关键弧。2，3步骤一个给出初始值，一个给出终值。但思路都是由后往前推，递归思想。</p>
</blockquote>
<p>应用：1956年，美国杜邦公司提出关键路径法，并于1957年首先用于1000万美元化工厂建设，工期比原计划缩短了4个月。杜邦公司在采用关键路径法的一年中，节省了100万美元。</p>
<p><em>最短路径</em></p>
<p>假如，一个旅客从A城到B城，他希望选择一条途中中转次数最少的路线。假设图中每一站都要换车，则这个问题反映到图上就是要找一条从顶点A到B所含边的数目最少的路径。我们只需从A出发对图作广度优先搜索，一旦遇到顶点B就终止。由此所得广度优先生成树上，从根顶点A到顶点B的路径就是中转次数最少的路径，路径A与B之间的顶点就是途径的中转站数。</p>
<p>本节将讨论带权有向图，并称路径上的第一个顶点为<code>源点</code>(Sourse)，最后一个顶点为<code>终点</code>(Destination)。</p>
<p>从某个源点到其余各顶点的最短路径</p>
<p><code>迪杰斯特拉</code>算法</p>
<p>首先，引进一个辅助向量D，它的每个分量D[i]表示当前所找到的从始点v到每个终点$v_i$的最短路径的长度。他的初态为：若从v到$v_i$有弧，则D[i]为弧上的权值；否则置D[i]为$\infty$。显然，长度为$D[j] = Min{D[i] | v_i \in V}$的路径就是从v出发的长度最短的一条，此路径为$(v, v_j)$</p>
<p>一般情况下，假设S为已求得最短路径的终点的集合，则可证明：下一条最短路径(设其终点为x)或者是弧(v,x)，或者是中间只经过S中的顶点而最后到达顶点x的路径。</p>
<p>因此在一般情况下，下一条长度次短的最短路径的长度必是：$D[j] = Min{D[i] | v_i /in V - S}$。其中，D[i]或者是弧$(v,v_i)$上的权值或者是$D<a href="v_k \in S">k</a>$和弧$(v_k, v_i)$上的权值之和。</p>
<p>根据以上分析，可得到如下描述的算法：</p>
<ol>
<li>假设用带权的邻接矩阵arcs来表示带权有向图，arcs[i][j]表示弧$(v_i,v_j)$上的权值。若$(v_i,v_j)$不存在，则置arcs[i][j]为$\infty$。S为已找到从v出发的最短路径的终点的集合，它的初始状态为空集。那么，从v出发到图上其余各顶点$v_i$可能达到的最短路径长度的初值为：$D[i] = arcs[Locate Vex(G, v)][i] v_i \in V$。</li>
<li>选择$v_j$，使得：$D[j] = Min{D[i] | v_i \in V-S }$。$v_j$就是当前求得的一条从v出发的最短路径的终点，令：$S = S \cup {j}$</li>
<li>修改从v出发到集合V-S上任一顶点$v_k$可达的最短路径长度。如果：D[j] + arcs[j][k] &lt; D[k]。则修改D[k]为D[k] = D[j] + arcs[j][k]</li>
<li>重复2，3共n-1次。由此求得从v到图上其余各顶点的最短路径是依路径长度递增的序列。</li>
</ol>
<p>迪杰斯特拉算法时间复杂度$O(n^2)$</p>
<p><em>每一对顶点之间的最短路径</em></p>
<p>很简单的方法是每次以一个顶点为源点，重复执行迪杰斯特拉算法n次，这样便可求的每一对顶点之间的最短路径。时间复杂度为$O(n^3)$。</p>
<p>弗洛伊德算法：时间复杂度也是$O(n^3)$，形式上要简单一点。</p>
<p>弗洛伊德算法仍然从带权的邻接矩阵cost出发，其基本思想为：</p>
<p>现在定义一个n阶方阵序列<br>$D^{-1},D^{0},D^{1},…,D^{k},…,D^{(n-1)}$</p>
<p>其中<br>$D^{-1}[i][j] = G.arcs[i][j]$<br>$D^{(k)}[i][j] = Min\{D^{(k-1)}[i][j],D^{(k-1)}[i][k] + D^{(k-1)}[k][i]\}  0 \le k \le n-1$ </p>
<blockquote>
<p>理解要点：递归思想，根据公式理解</p>
</blockquote>
<h3 id="动态存储管理"><a href="#动态存储管理" class="headerlink" title="动态存储管理"></a>动态存储管理</h3><p>动态存储管理的基本问题是系统如何应用户提出的‘请求’分配内存？又如何回收那些用户不再使用而‘释放’的内存，以备新的‘请求’产生时重新进行分配？</p>
<p>系统每次分配给用户都是一个地址连续的内存区。为了叙述方便起见，将统称已分配给用户使用的地址连续的内存区为‘占用快’，称未分配的地址连续的内存区为‘可利用空间块’或‘空闲块’。</p>
<p>当系统运行了一段时间后，内存区形成犬牙交错的形态，当有新的用户进入系统请求分配内存，那么系统应该如何做呢？</p>
<p>通常有两种做法：一种策略是系统继续从高地址的空闲块中进行分配，而不理会已分配给用户的内存区是否空闲，直到分配无法进行（即剩余的空间块不能满足分配的请求）时，系统才去回收所有用户不再使用的空闲块，并且重新组织内存，将所有空闲区连接在一起称为一个大的空闲块。另一种策略是用户一旦运行结束，便将它所占用的内存区释放为空闲块，同时，每当新的用户请求分配内存时，系统需要巡视整个内存区中所有空闲块，并从中找出一个‘合适’的空闲块分配之。由此，系统需建立一张记录所有空闲块的‘可利用空间表’，此表的结构可以是‘目录表’，也可以是‘链表’</p>
<p><em>可利用空间表及分配方法</em></p>
<p>下面仅讨论链表的情况</p>
<p>可以用空间表又称‘存储池’</p>
<p>根据系统的不同情况，可利用空间表可以有以下3种不同的结构形式：</p>
<ol>
<li>系统运行期间所有用户请求分配的存储量大小相同。对此类系统，通常的做法是，在系统开始运行时将归它使用的内存区按所需大小分割成大小相同的块，然后用指针链接成一个可利用空间表。由于表中结点大小相同，则分配时无需查找，只要将第一个结点分配给用户即可；同样，当用户释放内存时，系统只要将用户释放的空间块插入在表头即可。可见，这种情况下的可利用空间表实质上是一个链栈。这是一种最简单的动态存储管理方式。</li>
<li>系统运行期间，用户请求分配的存储量有若干种大小的规格。对此类系统，一般情况下是建立若干个可利用空间表，同一链表中的结点大小相同。每个结点中第一个字设有链域(link)、标志域(tag)和结点类型域(type)</li>
<li>系统运行期间分配给用户的内存块的大小不固定，可以随请求而变。因此，可利用空间表中结点即空闲块的大小也是随意的。通常，操作系统中的可利用空间表属这种类型。由于链表中结点大小不同，则结点的结构与前两种情况也有所不同，结点中除标志域和链域之外，尚需有一个结点大小域(size)，以指示空闲块的存储量。假设某用户需大小为n的内存，而可利用空间表中仅有一块大小为$m ge n$的空间快，则只需将其中大小为n的一部分分配给申请分配的用户，同时将剩余大小为m-n的部分作为一个结点留在链表中即可。然而，若可利用空间表中有若干个不小于n的空闲块时，该分配哪一块呢？通常，可有3种不同的分配策略：<ul>
<li>首次拟合法：从表头指针开始查找可利用空间表，将找到的第一个大小不小于n的空闲块的一部分分配给用户</li>
<li>最佳拟合法：将可利用空间表中一个不小于n且最接近n的空闲块的一部分分配给用户，为了节省时间，预先需要排序</li>
<li>最差拟合法：讲可利用空间表中不小于n且是链表中最大的空闲块的一部分分配给用户，为了节省时间，预先需要排序<br>上述三种分配策略个有所长。一般来说，最佳拟合法适用于请求分配的内存大小范围较广的系统。最差拟合法适用于请求分配大小范围较窄的系统。首次拟合介于二者之间，通常适用于系统事先不掌握运行期间可能出现的请求分配和释放的信息的情况。</li>
</ul>
</li>
</ol>
<p>从时间上来说，首次拟合 &lt; 最差拟合法 &lt; 最佳拟合法</p>
<p>为了更有效的利用内存，就要求系统在回收时应考虑将地址相邻的空闲块合并成尽可能大的结点。</p>
<p><em>边界标识法</em></p>
<p>边界标识法(boundary tag method)是操作系统中用以进行动态分区分配的一种存储管理方法。</p>
<p>分配算法（首次拟合法）</p>
<ul>
<li>假设找到的此块待分配的空闲块的容量为m个字，若每次分配只是从中分配n个字给用户，剩余m-n哥字大小的结点仍留在链表中，则在若干次分配后，链表中会出现一些容量极小总也分配不出去的空闲块，这就大大减慢了分配（查找）的速度。弥补的办法是：选定一个适当的常量e，当$m - n le e$时，就将容量为m的空闲块整块分配给用户；反之，只分配其中n个字的内存块。同时为了避免修改指针，约定将该结点中的高地址部分分配给用户。</li>
<li>如果每次分配都从同一个结点开始查找的话，势必造成存储量小的结点密集在头指针pav所指结点附近，这同样会增加查询较大空闲块的时间。反之，如果每次分配从不同的结点开始查找，使分配后剩余的小块均匀的分布在链表中<br>回收算法</li>
</ul>
<p>一旦用户释放占用块，系统需要立即回收以备新的请求产生时进行再分配。为了使物理地址毗邻的空闲结合成一个尽可能大的结点，则首先需要检查刚释放的占用块的左，右紧邻是否为空闲块。由于本系统在每个内存区的边界上都设有标志值，则很容易辨明这一点。</p>
<p>若释放块的左右邻块均为占用块，则处理最为简单，只要将此新的空闲块作为一个结点插入到可利用空闲表即可；若只有左邻区是空闲块，则应与左邻区合并成一个结点；若是只有右邻区是空闲块，则应与右邻区合并成一个结点；左右邻区都是空闲块，则应将3块合起来称为一个结点留在可利用空间表中。</p>
<p><em>伙伴系统</em></p>
<p><code>伙伴系统</code>(buddy system)是操作系统中用到的另一种动态存储管理方法。它和边界标识法类似，在用户提出申请时，分配一块‘恰当’的内存区给用户；反之，在用户释放内存区时即回收。所不同的是：在伙伴系统中，无论是占用块或空闲块，其大小均为2的k次幂。</p>
<p>可利用空间表的结构</p>
<p>假设系统的可利用内存空间容量为$2^m$个字（地址从0到$2^m - 1$）。则在开始运行时，整个内存区是一个大小为$2^m$的空闲块，在运行一段时间后，被分割成若干占用块和空闲快。为了再分配时查找方便起见，我们将所有大小相同的空闲块建于一张子表中。每个子表是一个双重链表，这样链表可能有m+1个，将这m+1个表头指针用向量结构组织成一个表，这就是伙伴系统中的可利用空间表。</p>
<p>分配算法</p>
<p>当用户提出大小为n的内存请求时，首先在可利用标上寻找结点大小与n相匹配的子表，若此子表非空，则将子表中任意一个结点分配之即可；若此子表为空，则需从结点更大的非空子表中去查找，直至找到一个空闲块，则将其中一部分分配给用户，而将剩余部分插入相应的子表中。</p>
<p>回收算法</p>
<p>在分配的时候经常需要将一个大的空闲块分裂成两个大小相等的存储区，这两个由同一个大块分裂出来的小块就称之‘互为伙伴’。</p>
<blockquote>
<p>思路是，内存按照2的倍数划分，如果两个空闲内存分别处于两个不同的2的同倍区间，则不能合并</p>
</blockquote>
<p><em>无用单元回收</em></p>
<p>有时，系统在不恰当的时候没有进行回收，会产生‘无用单元’和‘悬挂访问’<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="built_in">malloc</span>(size);</span><br><span class="line">p = null;</span><br></pre></td></tr></table></figure></p>
<p>上述为无用单元<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="built_in">malloc</span>(size);</span><br><span class="line">q = p;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure></p>
<p>上述为悬挂访问</p>
<p>结构性问题也会产生‘无用单元’，解决方案：</p>
<ul>
<li>使用访问计数器：在所有的广义表或字表中增加一个表头结点，并设立一个‘计数域’，它的值为指向该子表或广义表的指针数目。只有当该计数域的值为零时，此子表或广义表中结点才被释放。</li>
<li>收集无用单元：在程序运行过程中，对所有的链表结点，不管它是否还有用，都不回收，直到整个可利用空间表为空。此时才暂时中断执行程序，将所有当前不被使用的结点链接在一起，称为一个新的可利用空间表，而后程序再继续执行。显然在一般情况下，是无法辨别哪些结点是当前未被使用的。然而，对于一个正在运行的程序，哪些结点正在使用是容易查明的，这只要从所有当前正在运行的程序，哪些结点正在使用是容易查明的，这只要从所有当前正在工作的指针变量出发，顺链遍历，那么，所有链结在这些链上的结点都是占用的。反之，可利用存储空间中的其余结点就都是无用的了。由此，收集无用单元应分两步进行：第一步是对所有占用结点加上标志。回顾第五章的广义表存储结构可在每个结点上再加设一个标志（mark）域，假设在无用单元收集之前所有结点的标志域均置为‘0’，则加上标志就是将结点的标志域置为‘1’；第二步是对整个可利用存储空间顺序扫描一遍，将所有标志域为’0‘的结点链接成一个新的可利用空间表。值得注意的是：上述第二步是容易进行的，而第一步是在极其困难的条件下进行的，因此，人们的精力主要集中在研究标志算法上。下面我们介绍3中标志算法。</li>
</ul>
<p>标志算法</p>
<ol>
<li>递归算法：从上面所述可知，加标志的操作实质上是遍历广义表，将广义表中所有结点的标志域赋值‘1’。我们可以写出遍历（加标志）算法的递归定义。这个算法很简单，易于用允许递归的高级语言描述之。但是，它需要一个较大的实现递归用的栈的辅助内存，这部分内存不能用于动态分配。并且，由于列表的层次不定，使得栈的容量不容易确定，除非是在内存区开辟一个相当大的区域留作栈，否则就有可能由于在标志过程中因栈的溢出而使系统瘫痪。</li>
<li>非递归算法：前序遍历二叉树思想（深度优先搜索），广度有优先搜索。这两种非递归算法中，虽然附设的栈或队列的容量比递归算法中的栈容量小，但和递归算法有同样的问题，仍需要一个不确定量的附加存储，因此也不是理想的方法。</li>
<li>利用表结点本身的指针域标记遍历路径的算法： 利用指针变换可以解决内存占用问题</li>
</ol>
<p>三种方法个有利弊。第三种方法进行标志的时候不需要附加存储，使得动态分配的可利用空间得到充分利用，但是时间上开销很大。第二种方法操作简单，时间上要节省很多，然而需要占有一定空间，使动态分配所有的存储量减少。总之，无用单元的收集是很费时间的，不能在实时处理的情况下应用。</p>
<p>可利用内存区只有少量结点为无用结点时，收集无用单元的工作效率很低，当系统回复运行的时候，这些结点又很快被消耗掉，导致另一次无用单元的收集。如此下去有可能导致恶性循环，以致最后整个系统瘫痪。解决的办法可以由系统事先确定一个常数k，当收集到的无用单元数为k或更少时，系统就不再运行下去。</p>
<p><em>存储紧缩</em></p>
<p>另一种结构的动态存储管理方法</p>
<p>在整个动态存储管理的过程中，不管在哪个时刻，可利用空间都是一个地址连续的存储区，在编译程序中称之为‘堆’，每次分配都是从这个可利用空间中划出一块。但是回收用户释放的空闲块就比较麻烦。由于系统的可利用空间始终是一个地址连续的存储块，因此回收时必须将所释放的空闲块合并到整个堆上去才能重新使用，这就是‘存储紧缩’的任务。需要四步操作：</p>
<ol>
<li>计算占用块的新地址</li>
<li>修改用户的初始变量表</li>
<li>检查每个占用块中存储的数据</li>
<li>将所有占用块迁移到新地址去</li>
</ol>
<p>可见，存储紧缩法比无用单元收集法更为复杂，前者不仅要传送数据，而且还要修改所有占用块中的指针值，因此，存储紧缩也是一个系统操作，且非迫不得已就不用。</p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><code>查找表</code>(Search Table)：是由同一类型的数据元素（或记录）构成的集合。由于‘集合’中的数据元素之间存在着完全松散的关系，因此查找表是一种非常灵便的数据结构。</p>
<p>对查找表经常进行的操作有：</p>
<ol>
<li>查询某个‘特定的’数据元素是否在查找表中</li>
<li>检索某个‘特定的’数据元素的各种属性</li>
<li>在查找表中插入一个数据元素</li>
<li>查找表中删去某个数据元素</li>
</ol>
<p>若对查找表只作前两种统称为‘查找’的操作，则称此类查找表为<code>静态查找表</code>(Static Search Table)。若存在后两种操作，称为<code>动态查找表</code>(Dynamic Search Table)。</p>
<p><code>关键字</code>(Key)：数据元素（或记录）中某个数据项的的值，用它可以标识（识别）一个数据元素（或记录）。若此关键字可以唯一地标识一个记录，则称此关键字为<code>主关键字</code>(Primary Key)(对不同的记录，其主关键字均不同)。反之，称用以识别若干记录的关键字为<code>次关键字</code>(Secondary Key)</p>
<p><code>查找</code>：根据给定的某个值，在查找表中确定一个其关键字等于给定值记录或数据元素。若表中存在这样一条记录，则称查找是成功的，此时查找的结果为给出整个记录的信息，或指示该记录在查找表中的位置；若表中不存在关键字等于给定值的记录，则称查找不成功，此时查找的结果可给出一个‘空’记录或‘空’指针</p>
<p><em>静态查找表</em></p>
<p>顺序表的查找</p>
<p><code>顺序查找</code>(Sequential Search)的查找过程为：从表中最后一个记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值比较相等，则查找成功，找到所查记录，反之，若直至第一个记录，其关键字和给定值比较都不等，则表明表中没有所查记录，查找不成功。</p>
<p>查找操作的<code>性能分析</code></p>
<p>定义：为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值称为查找算法在查找成功时的<code>平均查找长度</code>(Average Search Length)。</p>
<p>公式：$ASL = \sum_{i=1}^n P_iC_i$ 其中：$P_i$为查找表中第i个记录的概率，且$\sum_{i=1}^n P_i = 1$。</p>
<p>$ASL_{ss} = \frac{n+1}{2}$</p>
<p>有序表的查找</p>
<p><code>折半查找</code>(Binary Search)：先确定待查记录所在的范围（区间），然后逐步缩小范围直到找到或找不到记录为止。</p>
<p>$ASL_{bs} = log_2(n+1) - 1$</p>
<p>可见，折半查找的效率比顺序查找高，但折半查找只适用于有序表，且限于顺序存储结构</p>
<p>以有序表表示静态查找表时，进行查找的方法除折半查找之外，还有斐波那契查找和插值查找。</p>
<p>斐波那契查找的平均性能比折半查找好，但最坏情况下的性能却比折半查找差。它还有一个优点就是分割的时候只需进行加，减运算</p>
<p>插值查找只适用于关键字分布均匀的表，在这种情况下，对表长较大的顺序表，其平均性能比折半查找好。</p>
<p>静态树表的查找</p>
<p>当有序表中各记录的查找概率不等时，如果只考虑查找成功的情况，则使查找性能最佳的判定树是其带权内路径长度之和PH值(PH值和平均查找长度成正比)：</p>
<p>$PH = \sum_{i=1}^n w_i h_i$</p>
<p>取最小值的二叉树。其中：n为二叉树上结点的个数（即有序表的长度）；$h_i$为第i个结点在二叉树上的层次数；结点的权$w_i = cp_i(i = 1,2…,n)$。其中$p_i$为结点的查找概率，c为某个常量。称PH值取最小的二叉树为<code>静态最优查找树</code>(Static Optimal Search)。静态最优查找树花费的时间代价较高，因此不做详细讨论。在此介绍一种构造近似最优查找数的有效算法。</p>
<p>已知一个按关键字有序的记录序列</p>
<p>$(r_l, r_{l+1}, … , r_h$ （9-8）</p>
<p>其中：$r_{l}.key  &lt; r_{l+1}.key &lt; … &lt; r_{h}.key$</p>
<p>与每个记录相应的权值为：${w_{l},w_{l+1}, … , w_{h}}$</p>
<p>现构造一棵二叉树，使这棵二叉树的带权内路径长度PH值在所有具有同样权值的二叉树中近似为最小，称这类二叉树为<code>次优查找树</code>(Nearly Optimal Search Tree)。</p>
<p>构造次优查找树的方法是：首先在式(9-8)所示的记录序列中取第i($l \le i \le h$)个记录构造根结点$r_i$，使得：</p>
<p> $\Delta P_{i} = | \sum_{j=i+1}^h w_j -  \sum_{j=l}^{i-1} w_j|$</p>
<p> 取最小值($\Delta P_{i} = min{\Delta P_{j}}, l \le j \le h$)，然后分别对子序列$(r_l, r_{l+1}, … , r_{i-1}$ 和$(r_{i+1}, … , r_{h}$ 构造两棵次优查找树。分别设为根结点$r_i$的左子树和右子树。</p>
<p> 为了便于计算$\Delta P$，引入累计权值和：$sw_i = \sum_{j=l}^i w_j$，并设$w_{l-1} = 0$，则：</p>
<p>  $\Delta P_{i} = |(sw_h + sw_{l-1}) - sw_i - sw_{i-1}|$</p>
<p>由此可得构造次优查找树的递归算法。</p>
<p>大量的实验研究表明，次优查找树和最优查找树的查找性能之差仅为1%-2%，很少超过3%，而且构造次优查找树的算法时间复杂度为O(nlogn)。</p>
<p>可见，在记录的查找概率不等时，可用次优查找树表示静态查找树，故又称静态树表。</p>
<p>索引顺序表的查找</p>
<p>索引项组成的索引表按关键字有序，则确定块的查找可以用顺序查找，亦可用折半查找，而块中记录是任意排列的，则在块中只能是顺序查找。由此，分块查找的算法即为两种算法的简单合成</p>
<p>$ASL_{bs} = L_b + L_w$</p>
<p>其中$L_b$为查找索引表确定所在块的平均查找长度。$L_w$为在块中查找元素的平均长度。</p>
<p>一般情况下，为进行分块查找，可以将长度为n的表均匀的分成b块，每块含有s个记录，即$b = \lceil n/s \rceil$；又假定表中每个记录的查找概率相等，则每块查找的概率为1/b，块中的每个记录的查找概率为1/s。</p>
<p>若用顺序查找确定所在块，则平均查找长度为：$ASL_{bs} = \frac{1}{2}(\frac{n}{s} + s) + 1$</p>
<p>若用折半查找确定所在块，则分块查找的平均查找长度为：$ASL_{bs} = log_{2}(\frac{n}{s} + 1) + \frac{s}{2}$</p>
<p><em>动态查找表</em></p>
<p>动态查找表的特点就是，表结构本身是在查找过程中动态生成的，即对于给定值key，若表中存在其关键字等于key的记录，则查找成功返回，否则插入关键字等于key的记录。</p>
<p>二叉排序树和平衡二叉树</p>
<p>假设i个关键字小于第一个关键字：<br>平均查找长度：$P(n,i) = 1 \frac n [1 + i*(P(i) + 1) + (n - i -1)(P(n-i-1)+1)]$<br>其中P(i)为含有i个结点的二叉排序树的平均查找长度，则P(i)+1为查找左子树中每个关键字所用比较次数的平均值</p>
<p>对上式取平均值：当$n ge 2$时，$ P(n) le 2(1 + 1 /frac n)lnn $</p>
<p>由此可见，在随机的情况下，二叉排序树的平均查找长度和logn是等数量级的，然而在某些情况下（概率约为46.5%），尚需在构成二叉排序树的过程中进行‘平衡化’处理，称为二叉平衡树。</p>
<p><em>平衡二叉树</em></p>
<p><code>平衡二叉树</code>(Balanced Binary Tree)又称AVL树。它或者是一颗空树，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差绝对值不超过1。若将二叉树上结点的平衡因子BF(Blance Factor)定义为该节点的左子树的深度减去该节点的右子树的深度，则平衡二叉树上所有的平衡因子只可能是-1，0和1。</p>
<p>二叉排序树构成平衡二叉树方法</p>
<ol>
<li>单向右旋平衡处理</li>
<li>单向左旋平衡处理</li>
<li>双向旋转(先左后右)平衡处理</li>
<li>双向旋转(先右后左)平衡处理</li>
</ol>
<p>平衡树查找分析：时间复杂度为O(logn)</p>
<p><em>B-树和B+树</em></p>
<p>B-树是一种平衡的多路查找树，它在文件系统中很有用。在此介绍这种树的结构及其查找算法</p>
<p>一棵m阶的B-树，或为空树，或为满足下列特性的m叉树： </p>
<ol>
<li>树中每个结点至多有m棵子树</li>
<li>若根结点不是叶子结点，则至少有两棵子树</li>
<li>除根之外的所有非终端结点至少有$\lceil m/2 \rceil$棵子树</li>
<li>所有的非终端结点中包含下列信息数据：$(n, A_0, K_1, A_1, K_2, A_2, … , K_n, A_n)$<br> 其中：$K_i(i=1, … ,n)$为关键字，且$K_i&lt;K_{i+1}$;$A_i(i=1, … ,n)$为指向子树根结点的指针，且指针$A_{i-1}$所指子树中所有结点的关键字均小于$K_i$，$A_n$所指子树中所有结点的关键字均大于$K_n$。</li>
<li>所有叶子结点都出现在同一层次上，并且不带信息</li>
</ol>
<p>由此可见，在B-树上进行查找的过程是一个顺时针查找结点和在结点关键字中进行查找的交叉进行过程</p>
<p>B-树查找分析<br>B-树上查找包含两种基本操作：1）在B-树中找结点。2）在结点中找关键字。<br>其中第一步是在磁盘上进行的，因此，在磁盘上进行查找的次数，即待查关键字所在结点再B-树上的层次数，是B-树查找效率的首要因素。</p>
<p>B+树</p>
<p>和B-树的差异</p>
<ol>
<li>有n棵子树的结点中含有n个关键字</li>
<li>所有的叶子结点中包含了全部关键字信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接</li>
<li>所有的非终端结点可以看成是索引部分，结点中仅含有其子树中的最大(或最小)的关键字。</li>
</ol>
<p>键树</p>
<p>键树又称<code>数字查找树</code>(Digital Search Trees)。它是一颗度&gt;=2的树。</p>
<p><em>哈希表</em></p>
<ol>
<li>哈希函数是一个映像，因此哈希函数的设定很灵活，只要使得任何关键字由此所得的哈希函数值都落在表长允许范围之内即可。</li>
<li><p>对不同的关键字可能得到同一哈希地址</p>
<h3 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h3></li>
</ol>
<p><code>排序</code>：将一个数据元素(或记录)的任意序列，重新排列成一个按关键字有序的序列。</p>
<p>假设$K_i = K_j$，且在排序前的序列中$R_i$领先于$R_j$。若在排序后的序列中$R_i$仍领先于$R_j$，则称所用的<code>排序方法是稳定的</code>。否则称<code>排序方法是不稳定的</code>。</p>
<p><code>内部排序</code>：指的是待排序记录存放在计算机随机存储器中进行的排序过程</p>
<p><code>外部排序</code>：指的是带排序记录数量很大，以致内存一次不能容纳全部记录。在排序过程中需要对外存进行访问的排序过程。</p>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><ol>
<li>直接插入排序<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">sqList</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(sqList.length === <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> sqList</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> newList = [sqList[<span class="number">0</span>]]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; sqList.length; i++) &#123;</span><br><span class="line">    innerloop:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = newList.length<span class="number">-1</span>; j &gt;=<span class="number">0</span> ; j--) &#123;</span><br><span class="line">      <span class="keyword">let</span> newEle = sqList[i]</span><br><span class="line">      <span class="keyword">let</span> ele = newList[j]</span><br><span class="line">      <span class="keyword">let</span> leftArr = newList.slice(<span class="number">0</span>,j+<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">let</span> rightArr = newList.slice(j+<span class="number">1</span>, newList.length)</span><br><span class="line">      <span class="keyword">if</span>(newEle &gt;= ele)&#123;</span><br><span class="line">        newList = [].concat(leftArr, newEle, rightArr)</span><br><span class="line">        <span class="keyword">break</span> innerloop</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(j === <span class="number">0</span> &amp;&amp; newEle &lt; ele)&#123;</span><br><span class="line">        newList = [].concat(newEle, rightArr)</span><br><span class="line">        <span class="keyword">break</span> innerloop</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[]=&#123;<span class="number">98</span>,<span class="number">76</span>,<span class="number">109</span>,<span class="number">34</span>,<span class="number">67</span>,<span class="number">190</span>,<span class="number">80</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">89</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++)<span class="comment">//循环从第2个元素开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;a[i<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp=a[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span> &amp;&amp; a[j]&gt;temp;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                a[j+<span class="number">1</span>]=a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            a[j+<span class="number">1</span>]=temp;<span class="comment">//此处就是a[j+1]=temp;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> f=<span class="number">0</span>;f&lt;k;f++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[f]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关键是第二个循环由后往前走，找到正确的位置必须跳出循环，时间复杂度是$O(n^2)$，注意c语言版本充分利用了原有空间！</p>
<ol start="2">
<li>折半插入排序</li>
<li>2-路插入排序</li>
<li>希尔排序<br>希尔排序(Shell’s Sort)又称‘缩小增量排序’(Diminishing Increment Sort)，它也是一种属插入排序类的方法，但在时间效率上较前几种排序方法有较大的改进<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNUM 10</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> n,<span class="keyword">int</span> t)</span></span>;<span class="comment">//t为排序趟数</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[MAXNUM],i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAXNUM;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;<span class="built_in">array</span>[i]);</span><br><span class="line">    shellSort(<span class="built_in">array</span>,MAXNUM,(<span class="keyword">int</span>)(<span class="built_in">log</span>(MAXNUM+<span class="number">1</span>)/<span class="built_in">log</span>(<span class="number">2</span>))); <span class="comment">//排序趟数应为log2(n+1)的整数部分</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAXNUM;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,<span class="built_in">array</span>[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//根据当前增量进行插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellInsert</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> n,<span class="keyword">int</span> dk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span>(i=dk;i&lt;n;i++)<span class="comment">//分别向每组的有序区域插入</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp=<span class="built_in">array</span>[i];</span><br><span class="line">        <span class="keyword">for</span>(j=i-dk;(j&gt;=i%dk)&amp;&amp;<span class="built_in">array</span>[j]&gt;temp;j-=dk)<span class="comment">//比较与记录后移同时进行</span></span><br><span class="line">            <span class="built_in">array</span>[j+dk]=<span class="built_in">array</span>[j];</span><br><span class="line">        <span class="keyword">if</span>(j!=i-dk)</span><br><span class="line">            <span class="built_in">array</span>[j+dk]=temp;<span class="comment">//插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//计算Hibbard增量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dkHibbard</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(<span class="built_in">pow</span>(<span class="number">2</span>,t-k+<span class="number">1</span>)<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> n,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shellInsert</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> n,<span class="keyword">int</span> dk)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">        shellInsert(<span class="built_in">array</span>,n,dkHibbard(t,i));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//此写法便于理解，实际应用时应将上述三个函数写成一个函数。</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">49</span>,<span class="number">55</span>,<span class="number">04</span>];</span><br><span class="line"><span class="keyword">var</span> len = arr.length;</span><br><span class="line"><span class="comment">//分段缩小循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> fraction = <span class="built_in">Math</span>.floor(len/<span class="number">2</span>); fraction&gt;<span class="number">0</span>; fraction = <span class="built_in">Math</span>.floor(fraction/<span class="number">2</span>))&#123;</span><br><span class="line">  <span class="comment">//基础循环</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = fraction; i&lt;len; i++)&#123;</span><br><span class="line">    <span class="comment">//分段排序循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = i - fraction; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[fraction+j]; j -= fraction)&#123;</span><br><span class="line">      <span class="keyword">var</span> temp = arr[j];</span><br><span class="line">      arr[j] = arr[fraction+j];</span><br><span class="line">      arr[fraction+j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>藉由交换进行排序的方法</p>
<ol>
<li><p>起泡排序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">49</span>,<span class="number">55</span>,<span class="number">04</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BubbleSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> cur = arr[j];</span><br><span class="line">      <span class="keyword">let</span> next = arr[j+<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span>(cur &gt; next)&#123;</span><br><span class="line">        arr[j+<span class="number">1</span>] = cur</span><br><span class="line">        arr[j] = next</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BubbleSort(arr)</span><br></pre></td></tr></table></figure>
</li>
<li><p>快速排序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">78</span>, <span class="number">131</span>, <span class="number">38</span>, <span class="number">12</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left, right</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = left;</span><br><span class="line">  <span class="keyword">let</span> j = right;</span><br><span class="line">  <span class="keyword">let</span> k = left;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (arr[k] &lt;= arr[j] &amp;&amp; j &gt; k) &#123;</span><br><span class="line">      j --</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[k]</span><br><span class="line">    arr[k] = arr[j]</span><br><span class="line">    arr[j] = temp</span><br><span class="line">    k = j</span><br><span class="line">    <span class="keyword">while</span> (arr[k] &gt;= arr[i] &amp;&amp; i &lt; k) &#123;</span><br><span class="line">      i ++</span><br><span class="line">    &#125;</span><br><span class="line">    temp = arr[k]</span><br><span class="line">    arr[k] = arr[i]</span><br><span class="line">    arr[i] = temp</span><br><span class="line">    k = i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>((k - left) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    quickSort(arr, left, k<span class="number">-1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>((right - k) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    quickSort(arr, k+<span class="number">1</span>, right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>快速排序平均性能最好，时间复杂度为O(nlogn)。缺点是占用栈空间，经过优化后空间复杂度可以为O(logn)</p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><ol>
<li>简单选择排序</li>
<li>树形选择排序</li>
<li>堆排序<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*AuthorJenaszhang</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.buildMaxHeap = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="built_in">Math</span>.floor(<span class="keyword">this</span>.length/<span class="number">2</span>)<span class="number">-1</span> ; i&gt;=<span class="number">0</span> ; i--)&#123;</span><br><span class="line">    <span class="keyword">this</span>.heapAdjust(i, <span class="keyword">this</span>.length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">   </span><br><span class="line"><span class="built_in">Array</span>.prototype.swap = <span class="function"><span class="keyword">function</span>(<span class="params">i,j</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = <span class="keyword">this</span>[i];</span><br><span class="line">  <span class="keyword">this</span>[i] = <span class="keyword">this</span>[j];</span><br><span class="line">  <span class="keyword">this</span>[j] = tmp; </span><br><span class="line">&#125;;</span><br><span class="line">   </span><br><span class="line"><span class="built_in">Array</span>.prototype.heapSort=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.buildMaxHeap();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="keyword">this</span>.length<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">this</span>.swap(<span class="number">0</span>,i);</span><br><span class="line">    <span class="keyword">this</span>.heapAdjust(<span class="number">0</span>,i);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line">   </span><br><span class="line"><span class="built_in">Array</span>.prototype.heapAdjust=<span class="function"><span class="keyword">function</span>(<span class="params">i,j</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> largest=i;</span><br><span class="line">  <span class="keyword">var</span> left=<span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> right=<span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span>(left&lt;j &amp;&amp; <span class="keyword">this</span>[largest] &lt; <span class="keyword">this</span>[left])&#123;</span><br><span class="line">    largest = left;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span>(right&lt;j &amp;&amp; <span class="keyword">this</span>[largest] &lt; <span class="keyword">this</span>[right])&#123;</span><br><span class="line">    largest = right; </span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span>(largest!=i)&#123;</span><br><span class="line">    <span class="keyword">this</span>.swap(i,largest);</span><br><span class="line">    <span class="keyword">this</span>.heapAdjust(largest,j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">var</span> a=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">[].push.apply(a,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">89</span>,<span class="number">57</span>,<span class="number">23</span>,<span class="number">72</span>,<span class="number">43</span>,<span class="number">105</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(a.heapSort());</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>基本思路是，假设要排序的序列本来就是一个个有序数列，然后逐渐合并</p>
<p>归并排序是稳定的排序算法，实现归并排序需要等数量的辅助空间，时间复杂度为O(nlogn)</p>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>基本思路是，按照关键码分组，由高到低是MSD，由低到高是LSD</p>
<p><code>基数排序</code>(Radix Sorting)是完全不同的一种排序方法。</p>
<h4 id="各种内部排序方法的比较讨论"><a href="#各种内部排序方法的比较讨论" class="headerlink" title="各种内部排序方法的比较讨论"></a>各种内部排序方法的比较讨论</h4><p>  排序方法  平均时间  最坏情况  辅助存储</p>
<ul>
<li>简单排序  $O(n^2)$ $O(n^2)$ O(1)</li>
<li>快速排序  O(nlogn) $O(n^2)$ O(logn)</li>
<li>堆排序    O(nlogn) O(nlogn) O(1)</li>
<li>归并排序  O(nlogn) O(nlogn) O(n)</li>
<li>基数排序  O(d(n + rd)) O(d(n + rd)) O(rd)</li>
</ul>
<h3 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h3><h4 id="外存信息的存取"><a href="#外存信息的存取" class="headerlink" title="外存信息的存取"></a>外存信息的存取</h4><p>计算机一般有两种存储器：内存储器(主存)和外存储器(辅存)。内存的信息可随机存储，且存取速度快，但价格贵，容量小。外存储器包括磁带和磁盘，前者为顺序存储设备，后者为随机存储设备。</p>
<ol>
<li>归并排序</li>
<li>置换-选择排序</li>
</ol>
<blockquote>
<p>重要概念是，外存是必须要读到内存中进行排序的，外存读取速度慢，容量大</p>
</blockquote>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><h4 id="有关文件的基本概念"><a href="#有关文件的基本概念" class="headerlink" title="有关文件的基本概念"></a>有关文件的基本概念</h4><ul>
<li><p>文件及其类别：操作系统中的文件仅是一维的连续的字符序列，无结构，无解释。它也是记录的集合，这个记录仅仅是一个字符组，用户为了存取、加工方便，把文件中的信息划分称若干组，每一组信息称为一个逻辑记录，且可按顺序编号。数据库中的文件是带有结构的记录的集合；这类记录是由一个或多个数据项组成的集合；这类记录是由一个或多个数据项组成的集合，它也是文件中可存取的数据的基本单位。数据项是最基本的不可分的数据单位，也是文件中可使用的数据的最小单位。若文件中每个记录含有的信息长度相同，则称这类记录为定长记录，由这类记录组成的文件称做<code>定长记录文件</code>。若文件中含有信息长度不等的不定长记录，则称<code>不定长记录文件</code>。数据库文件还分为单关键字文件和多关键字文件。</p>
</li>
<li><p>记录的逻辑结构和物理结构：逻辑结构着眼于用户使用方便；物理结构应该考虑提高存储空间的利用率和减少存取记录的时间。一个物理记录是指计算机用一条I/O命令进行读写的基本数据单位。物理记录和逻辑记录的关系：一个物理记录存放一个逻辑记录；一个物理记录包含多个逻辑记录；多个物理记录表示一个逻辑记录。</p>
</li>
<li><p>文件的操作(运算)：文件的操作有两种，检索和修改。<br>文件检索的三种方式</p>
<ol>
<li>顺序存取</li>
<li>直接存取</li>
<li>按关键字存取</li>
</ol>
</li>
<li><p>文件的物理结构：顺序组织，随机组织和链组织。一个特定的文件应才用何种物理结构应综合考虑各种因素：存储介质的类型、记录的类型、大小和关键字的数目以及对文件作何种操作等。</p>
</li>
</ul>
<h4 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h4><p><code>顺序文件</code>：顺序文件是记录按其在文件中的逻辑顺序依次进入存储介质而建立的，即顺序文件中物理记录的顺序和逻辑记录的顺序是一致的</p>
<h4 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h4><p><code>索引文件</code>：除了文件本身（称作数据区）之外，另建立一张指示逻辑记录和物理记录之间一一对应关系的表——索引表。这类包含文件数据区和索引表两大部分的文件称做索引文件。</p>
<h4 id="ISAM文件和VSAM文件"><a href="#ISAM文件和VSAM文件" class="headerlink" title="ISAM文件和VSAM文件"></a>ISAM文件和VSAM文件</h4><p><code>索引顺序存取方法</code>ISAM为 Indexed Sequential Access Methed 的缩写，它是一种专为磁盘存储设计的文件组织方式。由于磁盘是以盘组，柱面和磁道三级地址存取的设备，则可对磁盘上的数据文件建立盘组、煮面和磁道三级索引。</p>
<p><code>虚拟存储存取方法</code>VSAM是Virtual Storage Access Method 的缩写。这种存取方法利用了操作系统的虚拟存储器的功能，给用户提供方便。</p>
<h4 id="直接存取文件（散列文件）"><a href="#直接存取文件（散列文件）" class="headerlink" title="直接存取文件（散列文件）"></a>直接存取文件（散列文件）</h4><p>直接存取文件指的是利用杂凑（Hash）法进行组织的文件。它类似于哈希表，即根据文件中关键字的特点设计一种哈希函数和处理冲突的方法将记录散列到存储设备上，故又称散列文件。</p>
<h4 id="多关键字文件"><a href="#多关键字文件" class="headerlink" title="多关键字文件"></a>多关键字文件</h4><ul>
<li>多重表文件(Multilist File): 构造和修改都很容易，插入一个新纪录也很容易，但是删除一个记录很麻烦</li>
<li>倒排文件：次关键字中存放有序的物理记录，优点是查询方便，缺点是维护困难。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据结构/" rel="tag"># 数据结构</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/10/nodejs学习文件操作/" rel="next" title="nodejs学习文件操作">
                <i class="fa fa-chevron-left"></i> nodejs学习文件操作
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/11/13/c语言简要/" rel="prev" title="c语言简要">
                c语言简要 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">乱世天狼</p>
              <p class="site-description motion-element" itemprop="description">乱世天狼 | 前端 | html | css | html5 | css3 | react | redux | webpack | 哲学 | 精神 | 生活</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">67</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">48</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#引子"><span class="nav-number">1.</span> <span class="nav-text">引子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绪论"><span class="nav-number">2.</span> <span class="nav-text">绪论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二章"><span class="nav-number">3.</span> <span class="nav-text">第二章</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第三章"><span class="nav-number">4.</span> <span class="nav-text">第三章</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第四章-串"><span class="nav-number">5.</span> <span class="nav-text">第四章 串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第五章-数组和广义表"><span class="nav-number">6.</span> <span class="nav-text">第五章 数组和广义表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#树和二叉树"><span class="nav-number">7.</span> <span class="nav-text">树和二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#赫夫曼树及其应用"><span class="nav-number">7.1.</span> <span class="nav-text">赫夫曼树及其应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图"><span class="nav-number">8.</span> <span class="nav-text">图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态存储管理"><span class="nav-number">9.</span> <span class="nav-text">动态存储管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找"><span class="nav-number">10.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部排序"><span class="nav-number">11.</span> <span class="nav-text">内部排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#插入排序"><span class="nav-number">11.1.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快速排序"><span class="nav-number">11.2.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选择排序"><span class="nav-number">11.3.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#归并排序"><span class="nav-number">11.4.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基数排序"><span class="nav-number">11.5.</span> <span class="nav-text">基数排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#各种内部排序方法的比较讨论"><span class="nav-number">11.6.</span> <span class="nav-text">各种内部排序方法的比较讨论</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#外部排序"><span class="nav-number">12.</span> <span class="nav-text">外部排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#外存信息的存取"><span class="nav-number">12.1.</span> <span class="nav-text">外存信息的存取</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件"><span class="nav-number">13.</span> <span class="nav-text">文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#有关文件的基本概念"><span class="nav-number">13.1.</span> <span class="nav-text">有关文件的基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#顺序文件"><span class="nav-number">13.2.</span> <span class="nav-text">顺序文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引文件"><span class="nav-number">13.3.</span> <span class="nav-text">索引文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ISAM文件和VSAM文件"><span class="nav-number">13.4.</span> <span class="nav-text">ISAM文件和VSAM文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#直接存取文件（散列文件）"><span class="nav-number">13.5.</span> <span class="nav-text">直接存取文件（散列文件）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多关键字文件"><span class="nav-number">13.6.</span> <span class="nav-text">多关键字文件</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">乱世天狼</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
